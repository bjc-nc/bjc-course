---
layout: page
title: Everyone's Got Algorithms
unit: 6
uniturl: 06-searching-sorting
reading: 4
readingurl: 04-Everyone's-Got-Algorithms
---

Everyone's Got Algorithms
==================
This lecture focuses on algorithm analysis, focusing on the following learning objectives:

 * 17: The student can appropriately connect problems and potential algorithmic solutions.
 * 18: The student can evaluate algorithms analytically and empirically.
 
 Introduction
------------
The word "algorithm" is arguably one of the nerdiest words ever emitted from a human mouth. Fortunately for us, the meaning is far easier to understand than you would first think -- an algorithm is simply a set of steps that allow us to solve a particular problem. In fact, many other careers use algorithms, but have different names for them. 
* Cooks use or memorize recipes to prepare food.
* UPS Truck Drivers have "340 Methods," the UPS handbook for drivers, that describes 340 different protocols that should be followed and how long each one should take.
* Electricians follow the same general steps when replacing or adding cabling at different houses.
* Salesman often have scripts to follow when making a sales call. The scripts describe how to open the conversation (and possibly more) in order to increase the odds of gaining a client.
* Subway Sandwich Artists have a series of signs stuck to the inside of the counter that prompt the employees with what should be said.
* Do-It-Yourself projects all come with some sort of instructions. Directions, such as those for assembling a piece of furniture or a Lego kit, are algorithms.

Computer science algorithms are conceptual solutions to a problem (such as sorting a list), whereas the implementation of an algorithm is the actual code that brings the solution to life. The implementations themselves can typically be written in almost any programming language and run on any computer; the concepts behind the algorithm are not affected by these types of conditions, in the same way that the outcome of a well-written recipe should (hopefully) not be affected by the cook or kitchen.

Trash or Treasure?
------------
There will very often be more than one way to solve a particular problem. Let’s consider a chef’s algorithms: recipes. foodnetwork.com has 261 different recipes (when we wrote this page!) for making apple pie. If you’re trying to make a delicious apple pie for someone, you will have multiple recipes that you can use to achieve that goal, but not all of the outcomes will be the same. Many of the recipes will be inferior to others, but you will likely have several high quality recipes to choose from. Does that make them exactly the same? Nope! Different recipes have different trade-offs. Some recipes, for example, may take significantly longer to prepare than others. Others may use more expensive ingredients, or ingredients that you don’t have access to, or obscene amounts of sugar, or a variety of other conditions that impact their usefulness to you. 

What are some of the trade-offs for other types of algorithms, other than recipes? What do you think some of the trade-offs for computer science algorithms might be? Computer science is loaded with trade-offs and being able to choose between them is a critical skill for creating useful software. 

Get into a group and describe two trade-offs that you feel may be relevant to computer science projects, and explain how they may be related (i.e. how or when you may have to trade one for the other). Don't worry about being "correct" as much as having a justifiable connection between two trade-offs. Feel free to (a) mention trade-offs that haven't been mentioned at all yet, (b) expose a new connection between two trade-offs that have already been mentioned separately or (c) if you absolutely can't come up with a pair that hasn't been mentioned, add an new explanation or circumstance to another student's contribution explaining when it might occur.

